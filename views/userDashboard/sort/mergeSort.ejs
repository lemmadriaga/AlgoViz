<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Merge Sort & Graph Traversal Visualization | AlgoViz</title>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <style>
      .custom-button {
        background-color: #5800ff;
        color: white;
        padding: 0.5rem 1.5rem;
        font-weight: bold;
        border-radius: 5px;
        transition: all 0.3s;
      }
      .custom-button:hover {
        background-color: #7f00ff;
        transform: translateY(-2px);
        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.3);
      }

      .visualization-container {
        background-color: #f3f4f6;
        border-radius: 10px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        padding: 1rem;
        width: 90%;
        height: 600px;
        overflow: hidden;
      }

      .bar {
        display: inline-block;
        width: 30px;
        margin: 4px;
        background: linear-gradient(to top, #ff8c00, #ffd700);
        color: white;
        text-align: center;
        font-weight: bold;
        border-radius: 5px;
        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
      }
      .bar.sorted {
        background: linear-gradient(to top, #32cd32, #228b22);
      }

      .node {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: #5800ff;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        position: absolute;
        transition: all 0.3s;
      }
      .node.visited {
        background-color: #ffd700;
      }
      .edge {
        stroke: #5800ff;
        stroke-width: 2;
        transition: all 0.3s;
      }
      .edge.visited {
        stroke: #ffd700;
      }

      .step-process-container {
        background-color: #ffffff;
        border-radius: 10px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        padding: 1rem;
      }

      #graph-visualization {
        position: relative;
        width: 100%;
        height: 300px;
        background-color: #f3f4f6;
        border-radius: 10px;
        margin-top: 1rem;
      }
    </style>
  </head>
  <body class="bg-white p-8">
    <a href="javascript:history.back()" class="custom-button mb-4 inline-block"
      >Back</a
    >

    <div class="text-center mb-8">
      <h1 class="text-4xl font-bold text-purple-900">
        Merge Sort & Graph Traversal Visualization
      </h1>
    </div>

    <div class="flex justify-center space-x-8 mb-8">
      <div
        class="visualization-container flex justify-center items-center relative"
      >
        <div
          id="visualization"
          class="w-full h-full flex items-end justify-center"
        ></div>
      </div>

      <div class="step-process-container w-1/3 h-96 overflow-y-auto">
        <h2 class="text-xl font-semibold mb-4 text-purple-800 text-center">
          Algorithm Steps
        </h2>
        <div id="process" class="text-gray-700 text-sm"></div>
      </div>
    </div>

    <div class="flex flex-col items-center space-y-4">
      <input
        id="inputField"
        type="text"
        placeholder="Enter numbers, e.g., 5,3,8,1,4"
        class="border border-gray-300 p-2 rounded w-64 mb-4"
      />

      <div class="flex space-x-4 mt-4">
        <button onclick="startMergeSort()" class="custom-button">
          Start Sorting
        </button>
        <button onclick="pauseSorting()" class="custom-button">Pause</button>
        <button onclick="startGraphTraversal()" class="custom-button">
          Start Traversal
        </button>
      </div>
    </div>

    <div class="flex flex-col items-center mt-12">
      <h2 class="text-xl font-semibold mb-4 text-purple-800 text-center">
        Graph Visualization
      </h2>
      <div id="graph-visualization"></div>
    </div>

    <script>
      let array = [];
      let isPaused = false;
      let graph = {};
      let nodes = {};
      let edges = [];

      function displayArray(arr = array) {
        const visualization = document.getElementById("visualization");
        visualization.innerHTML = "";

        const maxValue = Math.max(...arr);
        const containerHeight = 550;

        arr.forEach((value) => {
          const bar = document.createElement("div");
          bar.className = "bar";
          const barHeight = (value / maxValue) * containerHeight;
          bar.style.height = `${barHeight}px`;
          bar.innerText = value;
          visualization.appendChild(bar);
        });
      }

      function displayProcessStep(message) {
        const processContainer = document.getElementById("process");
        const step = document.createElement("div");
        step.className = "text-sm text-gray-700 mb-2";
        step.innerText = message;
        processContainer.appendChild(step);
        processContainer.scrollTop = processContainer.scrollHeight;
      }

      function createGraph(inputArray) {
        graph = {};

        inputArray.forEach((value, index) => {
          graph[value] = [];
          if (index > 0) {
            graph[value].push(inputArray[index - 1]);
            graph[inputArray[index - 1]].push(value);
          }
          if (index < inputArray.length - 1) {
            graph[value].push(inputArray[index + 1]);
          }
        });
        return graph;
      }

      function createGraphVisualization() {
        const container = document.getElementById("graph-visualization");
        container.innerHTML = "";
        nodes = {};
        edges = [];

        const svg = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "svg"
        );
        svg.setAttribute("width", "100%");
        svg.setAttribute("height", "100%");
        container.appendChild(svg);

        const centerX = container.clientWidth / 2;
        const centerY = container.clientHeight / 2;
        const radius = Math.min(centerX, centerY) - 50;
        const nodeCount = Object.keys(graph).length;
        const angleStep = (2 * Math.PI) / nodeCount;

        Object.keys(graph).forEach((node, index) => {
          const angle = index * angleStep;
          const x = centerX + radius * Math.cos(angle);
          const y = centerY + radius * Math.sin(angle);

          const nodeElement = document.createElement("div");
          nodeElement.className = "node";
          nodeElement.innerText = node;
          nodeElement.style.left = `${x - 20}px`;
          nodeElement.style.top = `${y - 20}px`;
          container.appendChild(nodeElement);
          nodes[node] = nodeElement;

          graph[node].forEach((neighbor) => {
            if (parseInt(neighbor) > parseInt(node)) {
              const neighborIndex = Object.keys(graph).indexOf(
                neighbor.toString()
              );
              const neighborAngle = neighborIndex * angleStep;
              const neighborX = centerX + radius * Math.cos(neighborAngle);
              const neighborY = centerY + radius * Math.sin(neighborAngle);

              const line = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line"
              );
              line.setAttribute("x1", x);
              line.setAttribute("y1", y);
              line.setAttribute("x2", neighborX);
              line.setAttribute("y2", neighborY);
              line.setAttribute("class", "edge");
              svg.appendChild(line);
              edges.push({ element: line, nodes: [node, neighbor] });
            }
          });
        });
      }

      async function startMergeSort() {
        const input = document.getElementById("inputField").value;
        array = input.split(",").map(Number);
        document.getElementById("process").innerHTML = "";
        displayArray(array);
        displayProcessStep(`Starting array: [${array.join(", ")}]`);
        await mergeSort(array, 0, array.length - 1);
        displayProcessStep(`Sorted Array: [${array.join(", ")}]`);
        displayArray(array);
      }

      async function mergeSort(arr, left, right) {
        if (left >= right) return;
        const mid = Math.floor((left + right) / 2);

        await mergeSort(arr, left, mid);
        await mergeSort(arr, mid + 1, right);
        await merge(arr, left, mid, right);
      }

      async function merge(arr, left, mid, right) {
        let leftArray = arr.slice(left, mid + 1);
        let rightArray = arr.slice(mid + 1, right + 1);

        let i = 0,
          j = 0,
          k = left;
        while (i < leftArray.length && j < rightArray.length) {
          if (isPaused) await pauseLoop();

          if (leftArray[i] <= rightArray[j]) {
            arr[k] = leftArray[i];
            i++;
          } else {
            arr[k] = rightArray[j];
            j++;
          }
          displayArray(arr);
          displayProcessStep(
            `Merged: [${arr.slice(left, right + 1).join(", ")}]`
          );
          await sleep(500);
          k++;
        }

        while (i < leftArray.length) {
          arr[k] = leftArray[i];
          i++;
          k++;
        }
        while (j < rightArray.length) {
          arr[k] = rightArray[j];
          j++;
          k++;
        }
        displayArray(arr);
      }

      async function startGraphTraversal() {
        graph = createGraph(array);
        createGraphVisualization();
        displayProcessStep("Starting BFS traversal...");
        await bfs(array[0]);
      }

      async function bfs(start) {
        const visited = new Set();
        const queue = [start];

        while (queue.length > 0) {
          const current = queue.shift();

          if (!visited.has(current)) {
            visited.add(current);
            nodes[current].classList.add("visited");
            displayProcessStep(`Visiting node: ${current}`);

            edges.forEach((edge) => {
              if (edge.nodes.includes(current)) {
                edge.element.classList.add("visited");
              }
            });

            await sleep(500);

            for (const neighbor of graph[current]) {
              if (!visited.has(neighbor)) {
                queue.push(neighbor);
              }
            }
          }
        }
        displayProcessStep("BFS traversal completed!");
      }

      function pauseSorting() {
        isPaused = !isPaused;
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      async function pauseLoop() {
        while (isPaused) {
          await sleep(100);
        }
      }
    </script>
  </body>
</html>
